/// Riverpod providers for the Autonomous Execution Engine (Sprint J, AE.T01–AE.T20).
///
/// Exposes:
///   aePlanProvider(sessionId)   — latest AePlan for a session (null if none)
///   aeDecisionsProvider(sessionId) — list of session decisions
///   confidenceScoreProvider(taskId, sessionId) — 0.0–1.0 confidence score
library;

import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:clawd_core/clawd_core.dart';

// ─── AePlan types ─────────────────────────────────────────────────────────────

/// A JIRA-style task specification generated by the daemon's orchestration turn.
class AePlan {
  const AePlan({
    required this.id,
    required this.sessionId,
    required this.title,
    required this.requirements,
    required this.definitionOfDone,
    required this.filesExpected,
    required this.aiInstructions,
    required this.createdAt,
    this.approvedAt,
    this.parentTaskId,
  });

  final String id;
  final String sessionId;
  final String title;
  final List<String> requirements;
  final List<String> definitionOfDone;
  final List<String> filesExpected;
  final String aiInstructions;
  final String createdAt;
  final String? approvedAt;
  final String? parentTaskId;

  bool get isApproved => approvedAt != null;

  factory AePlan.fromJson(Map<String, dynamic> json) => AePlan(
        id: json['id'] as String,
        sessionId: json['sessionId'] as String,
        title: json['title'] as String,
        requirements: (json['requirements'] as List?)
                ?.map((e) => e as String)
                .toList() ??
            [],
        definitionOfDone: (json['definitionOfDone'] as List?)
                ?.map((e) => e as String)
                .toList() ??
            [],
        filesExpected: (json['filesExpected'] as List?)
                ?.map((e) => e as String)
                .toList() ??
            [],
        aiInstructions: json['aiInstructions'] as String? ?? '',
        createdAt: json['createdAt'] as String,
        approvedAt: json['approvedAt'] as String?,
        parentTaskId: json['parentTaskId'] as String?,
      );

  AePlan copyWith({String? approvedAt}) => AePlan(
        id: id,
        sessionId: sessionId,
        title: title,
        requirements: requirements,
        definitionOfDone: definitionOfDone,
        filesExpected: filesExpected,
        aiInstructions: aiInstructions,
        createdAt: createdAt,
        approvedAt: approvedAt ?? this.approvedAt,
        parentTaskId: parentTaskId,
      );
}

/// A single decision recorded during a session.
class AeDecision {
  const AeDecision({
    required this.id,
    required this.sessionId,
    required this.description,
    required this.createdAt,
  });

  final String id;
  final String sessionId;
  final String description;
  final String createdAt;

  factory AeDecision.fromJson(Map<String, dynamic> json) => AeDecision(
        id: json['id'] as String,
        sessionId: json['sessionId'] as String,
        description: json['description'] as String,
        createdAt: json['createdAt'] as String,
      );
}

/// Confidence score with signal breakdown.
class ConfidenceData {
  const ConfidenceData({
    required this.planId,
    required this.score,
    required this.signals,
  });

  final String planId;
  /// 0.0–1.0.
  final double score;
  final List<ConfidenceSignal> signals;

  factory ConfidenceData.fromJson(Map<String, dynamic> json) => ConfidenceData(
        planId: json['planId'] as String,
        score: (json['score'] as num?)?.toDouble() ?? 0.0,
        signals: (json['signals'] as List?)
                ?.map((s) => ConfidenceSignal.fromJson(s as Map<String, dynamic>))
                .toList() ??
            [],
      );
}

/// A single evidence signal for the confidence score.
class ConfidenceSignal {
  const ConfidenceSignal({
    required this.name,
    required this.present,
    required this.weight,
  });

  final String name;
  final bool present;
  final double weight;

  factory ConfidenceSignal.fromJson(Map<String, dynamic> json) =>
      ConfidenceSignal(
        name: json['name'] as String,
        present: json['present'] as bool? ?? false,
        weight: (json['weight'] as num?)?.toDouble() ?? 0.0,
      );
}

// ─── aePlanProvider ───────────────────────────────────────────────────────────

/// Fetches the most-recently created AePlan for [sessionId].
///
/// Returns `null` when no plan has been generated yet for this session.
/// The provider is invalidated when the daemon emits `ae.planReady` or
/// `ae.planApproved` (handled in the event listener — see chat_screen.dart).
final aePlanProvider =
    FutureProvider.family<AePlan?, String>((ref, sessionId) async {
  // The daemon does not yet expose a ae.plan.listBySession RPC — we rely
  // on the plan being pushed via ae.planReady and cached locally.
  // This provider fetches from the push-event cache held in aePlanCacheProvider.
  return ref.watch(aePlanCacheProvider(sessionId));
});

// ─── aePlanCacheProvider ──────────────────────────────────────────────────────

/// State provider that caches the latest AePlan for each session.
///
/// Updated by the event listener when the daemon emits `ae.planReady`
/// or `ae.planApproved`.
final aePlanCacheProvider =
    StateProvider.family<AePlan?, String>((ref, sessionId) => null);

// ─── aeDecisionsProvider ──────────────────────────────────────────────────────

/// Fetches all decisions recorded for [sessionId].
final aeDecisionsProvider =
    FutureProvider.family<List<AeDecision>, String>((ref, sessionId) async {
  // Stub: the daemon ae.decision.list RPC is not yet implemented.
  // Returns empty list until the handler is wired.
  return [];
});

// ─── confidenceScoreProvider ──────────────────────────────────────────────────

/// Parameters for the combined (planId, sessionId) confidence lookup.
class ConfidenceParams {
  const ConfidenceParams({required this.planId, required this.sessionId});
  final String planId;
  final String sessionId;

  @override
  bool operator ==(Object other) =>
      other is ConfidenceParams &&
      other.planId == planId &&
      other.sessionId == sessionId;

  @override
  int get hashCode => Object.hash(planId, sessionId);
}

/// Fetches the confidence score for [params.planId] / [params.sessionId].
final confidenceScoreProvider =
    FutureProvider.family<ConfidenceData?, ConfidenceParams>(
  (ref, params) async {
    final client = ref.read(daemonProvider.notifier).client;
    try {
      final result = await client.call<Map<String, dynamic>>(
        'ae.confidence.get',
        {
          'planId': params.planId,
          'sessionId': params.sessionId,
        },
      );
      return ConfidenceData.fromJson(result);
    } catch (_) {
      return null;
    }
  },
);

// ─── Autonomous actions ───────────────────────────────────────────────────────

final autonomousActionsProvider = Provider<AutonomousActions>(
  (ref) => AutonomousActions(ref),
);

class AutonomousActions {
  const AutonomousActions(this._ref);
  final Ref _ref;

  /// Ask the daemon to generate a plan for [message] in [sessionId].
  Future<AePlan?> createPlan(String sessionId, String message) async {
    final client = _ref.read(daemonProvider.notifier).client;
    final result = await client.call<Map<String, dynamic>>(
      'ae.plan.create',
      {'sessionId': sessionId, 'message': message},
    );
    final plan = AePlan.fromJson(result);
    // Update the local cache immediately.
    _ref.read(aePlanCacheProvider(sessionId).notifier).state = plan;
    return plan;
  }

  /// Approve the plan identified by [planId] for [sessionId].
  Future<void> approvePlan(String sessionId, String planId) async {
    final client = _ref.read(daemonProvider.notifier).client;
    final result = await client.call<Map<String, dynamic>>(
      'ae.plan.approve',
      {'planId': planId},
    );
    final approvedAt = result['approvedAt'] as String?;
    final current = _ref.read(aePlanCacheProvider(sessionId));
    if (current != null && approvedAt != null) {
      _ref.read(aePlanCacheProvider(sessionId).notifier).state =
          current.copyWith(approvedAt: approvedAt);
    }
  }

  /// Record a key decision made during the session.
  Future<void> recordDecision(String sessionId, String description) async {
    final client = _ref.read(daemonProvider.notifier).client;
    await client.call<Map<String, dynamic>>(
      'ae.decision.record',
      {'sessionId': sessionId, 'description': description},
    );
    _ref.invalidate(aeDecisionsProvider(sessionId));
  }
}
