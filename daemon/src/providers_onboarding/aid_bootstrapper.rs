// SPDX-License-Identifier: MIT
//! AID (AI Config) bootstrapper â€” project-level VISION.md + FEATURES.md stubs.
//!
//! Covers PO.T13â€“PO.T15: detect missing `.claude/` directory, offer bootstrap,
//! and write minimal VISION.md + FEATURES.md stubs from the detected stack profile.

use anyhow::{Context, Result};
use chrono::Utc;
use std::path::Path;
use tracing::{debug, info};

use crate::repo_intelligence::RepoProfile;

/// Returns `true` if the repo at `repo_path` has NO `.claude/` directory â€”
/// i.e. it has not been configured with any AI instruction files yet.
///
/// Called by the `repo.open` handler to decide whether to emit `repo.noAidFound`.
pub fn check_repo_for_aid(repo_path: &Path) -> bool {
    // If .claude/ exists the repo is already configured.
    !repo_path.join(".claude").exists()
}

/// Bootstrap result for a single repo.
#[derive(Debug)]
pub struct BootstrapResult {
    pub vision_path: std::path::PathBuf,
    pub features_path: std::path::PathBuf,
    pub claude_dir: std::path::PathBuf,
}

/// Bootstrap the AI config directory for a repo.
///
/// Creates the following structure under `repo_path/.claude/`:
/// ```text
/// .claude/
///   CLAUDE.md          â€” brief repo-specific instructions stub
///   docs/
///     VISION.md        â€” product vision stub
///     FEATURES.md      â€” feature inventory stub
///   tasks/
///     active.md        â€” task tracking stub
///   memory/
///     decisions.md     â€” architecture decision log stub
/// ```
///
/// Existing files are never overwritten.
pub async fn bootstrap_aid(repo_path: &Path, profile: &RepoProfile) -> Result<BootstrapResult> {
    let repo_name = repo_path
        .file_name()
        .and_then(|n| n.to_str())
        .unwrap_or("unknown");

    let claude_dir = repo_path.join(".claude");
    let docs_dir = claude_dir.join("docs");
    let tasks_dir = claude_dir.join("tasks");
    let memory_dir = claude_dir.join("memory");

    // Create directory structure.
    for dir in &[&claude_dir, &docs_dir, &tasks_dir, &memory_dir] {
        tokio::fs::create_dir_all(dir)
            .await
            .with_context(|| format!("failed to create {}", dir.display()))?;
    }

    let vision_path = docs_dir.join("VISION.md");
    let features_path = docs_dir.join("FEATURES.md");
    let claude_md_path = claude_dir.join("CLAUDE.md");
    let active_tasks_path = tasks_dir.join("active.md");
    let decisions_path = memory_dir.join("decisions.md");

    // Write VISION.md stub.
    write_if_missing(&vision_path, &render_vision_stub(repo_name, profile)).await?;

    // Write FEATURES.md stub.
    write_if_missing(&features_path, &render_features_stub(repo_name, profile)).await?;

    // Write CLAUDE.md repo-level stub.
    write_if_missing(&claude_md_path, &render_claude_md_stub(repo_name, profile)).await?;

    // Write tasks/active.md stub.
    write_if_missing(&active_tasks_path, &render_active_tasks_stub(repo_name)).await?;

    // Write memory/decisions.md stub.
    write_if_missing(&decisions_path, &render_decisions_stub(repo_name)).await?;

    info!(repo = %repo_path.display(), "bootstrapped AI config directory");

    Ok(BootstrapResult {
        vision_path,
        features_path,
        claude_dir,
    })
}

// â”€â”€â”€ Stub renderers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

fn render_vision_stub(repo_name: &str, profile: &RepoProfile) -> String {
    let date = Utc::now().format("%Y-%m-%d").to_string();
    let lang = profile.primary_lang.as_str();

    format!(
        r#"# {repo_name} â€” Vision

> Stub generated by ClawDE on {date}. Fill in the blanks below.

## Vision

[TODO: One sentence â€” what is the ultimate goal of this project?]

## Mission

[TODO: What does this project do, for whom, and why does it matter?]

## Core Principles

- [TODO: Principle 1]
- [TODO: Principle 2]
- [TODO: Principle 3]

## Non-Goals

- [TODO: What this project will NOT do]

## Tech Context

- Primary language: {lang}
- Stack: {stack}
- Scanned: {date}
"#,
        stack = format_stack(profile)
    )
}

fn render_features_stub(repo_name: &str, profile: &RepoProfile) -> String {
    let date = Utc::now().format("%Y-%m-%d").to_string();
    let lang = profile.primary_lang.as_str();

    format!(
        r#"# {repo_name} â€” Feature Inventory

> Stub generated by ClawDE on {date}. Update as features are planned and built.

## Status Legend

| Symbol | Status |
|--------|--------|
| âœ… | Done â€” production-ready |
| ðŸš§ | In Progress |
| ðŸ”² | Planned |
| ðŸš« | Deferred |

---

## Core Features ({lang})

| Feature | Status | Notes |
|---------|--------|-------|
| [TODO: Feature 1] | ðŸ”² | |
| [TODO: Feature 2] | ðŸ”² | |
| [TODO: Feature 3] | ðŸ”² | |

---

## Stack Detected

{stack_summary}

---

*This file is maintained by the team. Update status symbols as features ship.*
"#,
        stack_summary = format_stack_summary(profile)
    )
}

fn render_claude_md_stub(repo_name: &str, profile: &RepoProfile) -> String {
    let date = Utc::now().format("%Y-%m-%d").to_string();
    let lang = profile.primary_lang.as_str();

    format!(
        r#"# {repo_name} â€” AI Instructions

> Generated by ClawDE on {date}

## Repo Overview

[TODO: Brief description of what this repo does]

Primary language: {lang}
Stack: {stack}

## Key Rules

- [TODO: Add project-specific rules here]

## Files Not to Touch

- [TODO: List any files that should not be modified by AI]

## Patterns

See `memory/decisions.md` for architecture decisions.
"#,
        stack = format_stack(profile)
    )
}

fn render_active_tasks_stub(repo_name: &str) -> String {
    let date = Utc::now().format("%Y-%m-%d").to_string();
    format!(
        r#"# {repo_name} â€” Active Tasks

**Sprint:** [TODO]
**Started:** {date}

---

## Phase 1: Setup [PLANNED ðŸ”²]

| # | Task | Status | Weight |
|---|------|--------|--------|
| T01 | Fill in VISION.md | ðŸ”² planned | XS |
| T02 | Fill in FEATURES.md | ðŸ”² planned | XS |
| T03 | Add project-specific rules to CLAUDE.md | ðŸ”² planned | XS |

---

*Add tasks before starting work. Mark done the moment each task completes.*
"#
    )
}

fn render_decisions_stub(repo_name: &str) -> String {
    let date = Utc::now().format("%Y-%m-%d").to_string();
    format!(
        r#"# {repo_name} â€” Architecture Decisions

> Log significant technical decisions here. Decisions are final until explicitly revisited.

## Format

**Decision:** [Short title]
**Date:** [YYYY-MM-DD]
**Context:** [Why this decision was needed]
**Choice:** [What was decided]
**Rationale:** [Why this choice over alternatives]
**Status:** Final / Revisited

---

## Decisions

*(None yet â€” add your first decision when you make one)*

---

*Bootstrapped by ClawDE on {date}*
"#
    )
}

// â”€â”€â”€ Stack helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

fn format_stack(profile: &RepoProfile) -> String {
    let mut parts = vec![profile.primary_lang.as_str().to_string()];
    for lang in &profile.secondary_langs {
        parts.push(lang.as_str().to_string());
    }
    for fw in &profile.frameworks {
        parts.push(fw.as_str().to_string());
    }
    parts.join(", ")
}

fn format_stack_summary(profile: &RepoProfile) -> String {
    let mut lines = vec![format!(
        "- Primary language: {}",
        profile.primary_lang.as_str()
    )];

    if !profile.secondary_langs.is_empty() {
        let secondary: Vec<&str> = profile.secondary_langs.iter().map(|l| l.as_str()).collect();
        lines.push(format!("- Secondary: {}", secondary.join(", ")));
    }

    if !profile.frameworks.is_empty() {
        let fws: Vec<&str> = profile.frameworks.iter().map(|f| f.as_str()).collect();
        lines.push(format!("- Frameworks: {}", fws.join(", ")));
    }

    if !profile.build_tools.is_empty() {
        let bts: Vec<&str> = profile.build_tools.iter().map(|b| b.as_str()).collect();
        lines.push(format!("- Build tools: {}", bts.join(", ")));
    }

    lines.join("\n")
}

// â”€â”€â”€ Utility â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

/// Write `content` to `path` only if the file does not already exist.
async fn write_if_missing(path: &Path, content: &str) -> Result<()> {
    if path.exists() {
        debug!(path = %path.display(), "skipping â€” file already exists");
        return Ok(());
    }
    tokio::fs::write(path, content)
        .await
        .with_context(|| format!("failed to write {}", path.display()))?;
    debug!(path = %path.display(), "wrote stub file");
    Ok(())
}
